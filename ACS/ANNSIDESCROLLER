#library "ANNSIDESCROLLER"
#include "zcommon.acs"

// Constants - Scaled down to prevent overflow
#define FIXED_POINT_SCALE 0.03125 // 1/16 = 0.0625; 1/32 = 0.03125;
#define SUBPIXELS_PER_PIXEL 256
#define X_ACCEL 16.0
#define X_MAX_SPEED 768.0 // 3 pixels
#define X_MAX_SPEED_FORCE_DECEL 32.0
#define Y_ACCEL_JUMP_HELD 40.0
#define Y_ACCEL_NORMAL 160.0
#define Y_TERMINAL_VELOCITY 1024.0
#define INITIAL_JUMP_SPEED 1184.0
#define GROUND_POUND_SPEED 2048.0

// Global variables
int xSpeed = 0;
int ySpeed = 0;
int isGrounded = 0;
int isGroundPounding = 0;
int groundPoundTimer = 0;
int jumpReleased = 1;

int axisDeadzone = 1000;

bool inputTiltUp = 0;
bool inputTiltDown = 0;

int attackHeld = 0;
bool attackJustPressed = 0;
bool attackJustReleased = 0;

int playerTids[32] = {1000,};

int actualVerticalMovementDistance = 0.0;

str strDebug = "";
bool shouldDrawDebugText = 1;

int attackState = 0;
int attackPhaseTimer = 0;

int ticks = 0;

// TIDS

int moveMe = 300;
int moveMeToo = 301;
int moveMeCamera = 302;

bool viewingCamera = 1;

function int abs (int x)
{
    if (x < 0)
        return -x;
    return x;
}

function void drawDebugText(void)
{
	if (shouldDrawDebugText) 
	{
		//strDebug = StrParam(s:"Accelerating: Dir=", i:moveDir, s:" Speed=", f:xSpeed);
		HudMessage(s:strDebug; HUDMSG_FADEOUT, 900, CR_YELLOW, -0.25, -0.25, 1.0, 1.0);
		strDebug = "";                                                                                                                                                                                                                                     
	}
}

function str AddDebugTextLine(str strIn)
{
	strDebug = StrParam(s:strDebug, s:strIn, s:"\n");
	return strDebug;
}


function void PerformAttackUp(void)
{
	attackState = 1;
	attackPhaseTimer = 20;
}

function void PerformAttackDown(void)
{
	attackState = 2;
	attackPhaseTimer = 20;
}

function void PerformAttackNeutral(void)
{
	attackState = 3;
	attackPhaseTimer = 20;
}

function void PerformAttackAirUp(void)
{
	attackState = 4;
	attackPhaseTimer = 20;
}

function void PerformAttackAirDown(void)
{
	attackState = 5;
	attackPhaseTimer = 20;
}

function void PerformAttackAirNeutral(void)
{
	attackState = 6;
	attackPhaseTimer = 20;
}

script 1 ENTER
{
	int newTid = 1000*PlayerNumber();
	Thing_ChangeTID(0, newTid);
	print(s:"New Player TID set to: ", i:newTid);
	log(s:"New Player TID set to: ", i:newTid);
    print(s:"Movement system initialized");
    ChangeCamera(moveMeCamera, 0, 0);
    ACS_NamedExecute("platformerMainLoop", 0);
}

script "platformerMainLoop" (void)
{
    print(s:"Started movement loop");
	// SetGravity(0.0);
    while(1)
    {
        // Get input
        int buttons = GetPlayerInput(-1, INPUT_BUTTONS);
        int strafeAxis = GetPlayerInput(-1, INPUT_SIDEMOVE);
		int forwardAxis = GetPlayerInput(-1, INPUT_FORWARDMOVE);
		
		// Debug print input
		inputTiltUp = 0;
		inputTiltDown = 0;
        if (abs(forwardAxis) > axisDeadzone)
        {
            //print(s:"Moving: ", i:strafeAxis);
			AddDebugTextLine(StrParam(s:"Tilting: ", i:strafeAxis));
			if (forwardAxis > axisDeadzone || (buttons & BT_FORWARD)) 
			{
				inputTiltUp = 1;
			}
			else if (forwardAxis < -axisDeadzone || (buttons & BT_BACK)) 
			{
				inputTiltDown = 1;
			}			
        }
		
		AddDebugTextLine(StrParam(s:"inputTiltUp: ", b:inputTiltUp));
		AddDebugTextLine(StrParam(s:"inputTiltDown: ", b:inputTiltDown));
		
		attackJustPressed = 0;
		attackJustReleased = 0;
		
		if (buttons & BT_ATTACK) 
		{
			if (attackHeld == 0) {attackJustPressed = 1;}
			attackHeld++;
		}
		else 
		{
			if (attackHeld > 0) {attackJustReleased = 1;}
			attackHeld = 0;
		}
		
		// Grounded attacks
		if (isGrounded) 
		{
			if (attackJustPressed && inputTiltUp && isGrounded) 
			{
				PerformAttackUp();
			}
			else if (attackJustPressed && inputTiltDown) 
			{
				PerformAttackDown();
			}
			else if (attackJustPressed) 
			{
				PerformAttackNeutral();
			}
		}
		
		// Air Attacks
		if (!isGrounded)
		{
			if (attackJustPressed && inputTiltUp) 
			{
				PerformAttackAirUp();
			}
			else if (attackJustPressed && inputTiltDown) 
			{
				PerformAttackAirDown();
			}
			else if (attackJustPressed) 
			{
				PerformAttackAirNeutral();
			}
		}
		
		
		if (attackPhaseTimer > 0)
		{
			attackPhaseTimer--;
			AddDebugTextLine(StrParam(s:"AttackState / Attack Phase Time: ", i:attackState, s:" / ", i:attackPhaseTimer));
		}
		
		if (attackPhaseTimer == 0 && attackState > 0) 
		{
			if (attackState != 10) 
			{
				attackState = 10;
				attackPhaseTimer = 6;
			}
			else 
			{
				attackState = 0;
			}
		}
        
        // Debug print input
        if (abs(strafeAxis) > axisDeadzone || (buttons & BT_MOVERIGHT))
        {
            //print(s:"Moving: ", i:strafeAxis);
			AddDebugTextLine(StrParam(s:"Moving: ", i:strafeAxis));
			
        }

        // Horizontal movement
        if ((abs(strafeAxis) > axisDeadzone || (buttons & BT_FORWARD)) && !isGroundPounding)
        {
            // Apply acceleration in movement direction
            int moveDir = strafeAxis > 0 ? 1 : -1;
            xSpeed += moveDir * X_ACCEL;  // FixedPoint times Int results in a Float. Don't use FixedMul for this.
            
            // Debug acceleration
            //print(s:"Accelerating: Dir=", i:moveDir, s:" Speed=", f:xSpeed);
			AddDebugTextLine(StrParam(s:"Accelerating: Dir=", i:moveDir, s:" Speed=", f:xSpeed));
            
            // Cap speed
            if (abs(xSpeed) > X_MAX_SPEED)
            {
                xSpeed -= moveDir * X_MAX_SPEED_FORCE_DECEL;
                ////print(s:"Speed capped at: ", f:xSpeed);
				AddDebugTextLine(StrParam(s:"Speed capped at: ", f:xSpeed));
            }
        }
        else if (!isGroundPounding)
        {
            // Decelerate when no movement input
            xSpeed = FixedMul(xSpeed, 0.8);
        }
		
		// Vertical movement.
		        // Jumping
        // if ((buttons & BT_JUMP) && isGrounded && jumpReleased)
		if ((buttons & BT_JUMP) && isGrounded && jumpReleased)
        {
            ySpeed = INITIAL_JUMP_SPEED;
            isGrounded = 0;
            jumpReleased = 0;
			
			// TODO: Alternate Jump actions based on tilt?
        }
        else if (!(buttons & BT_JUMP))
        {
            jumpReleased = 1;
            if (ySpeed > 0)  // Cut jump height when button released
            {
                ySpeed = 0;
            }
        }

        // Ground pound (Use button in this example)
        if ((buttons & BT_USE) && !isGrounded && !isGroundPounding)
        {
            isGroundPounding = 1;
            groundPoundTimer = 23;  // 23 frame windup
            xSpeed = 0;
			
			//This bit is for testing:
			if (viewingCamera) 
			{
				ChangeCamera(0, -1, 0);
			}
			else 
			{
				ChangeCamera(moveMeCamera, -1, 0);
			}
			viewingCamera = !viewingCamera;
        }

        // Ground pound physics
        if (isGroundPounding)
        {
            if (groundPoundTimer > 0)
            {
                groundPoundTimer--;
                if (groundPoundTimer == 0)
                {
                    ySpeed = -GROUND_POUND_SPEED;
                }
            }
        }

        // Apply gravity if not grounded
        if (!isGrounded)
        {
            int gravityAccel = (buttons & BT_JUMP) && !isGroundPounding ? 
                              Y_ACCEL_JUMP_HELD : Y_ACCEL_NORMAL;
            ySpeed -= gravityAccel;

            // Cap fall speed
            if (ySpeed < -Y_TERMINAL_VELOCITY)
            {
                ySpeed = -Y_TERMINAL_VELOCITY;
            }
        }
        
        // Move actor
        
		
		SetActorProperty(moveMe, APROP_GRAVITY, 0);
		SetActorProperty(moveMeToo, APROP_GRAVITY, 0);
		SetActorProperty(moveMeCamera, APROP_GRAVITY, 0);
        
        /*
		SetActorVelocity(moveMe, 
            xSpeed * 100.0
            0,
            ySpeed,
            0,0);
		*/
			
		/*
		SetActorPosition(moveMe, 
            GetActorX(moveMe) + FixedMul(xSpeed, FIXED_POINT_SCALE*2),
            GetActorY(moveMe),
            GetActorZ(moveMe) + FixedMul(ySpeed, FIXED_POINT_SCALE),
            0);
			*/
			
		SetActorVelocity(moveMe, 
            0,
            0,
            0,
            0,0);
			
		int mmaz = GetActorZ(moveMe);
		int mmafz = GetActorFloorZ(moveMe);
			
		actualVerticalMovementDistance = FixedMul(ySpeed, FixedMul(FIXED_POINT_SCALE,0.125));
		
		// Don't trust the game to handle floor zipping/collision well.
		if (mmaz + actualVerticalMovementDistance <= mmafz) 
		{
			actualVerticalMovementDistance = mmafz - mmaz;
			AddDebugTextLine(StrParam(s:"floor HIT"));
		}
			
		// Apply Vertical Movement
		SetActorPosition(moveMe, 
            GetActorX(moveMe),
            GetActorY(moveMe),
            GetActorZ(moveMe) + actualVerticalMovementDistance,
            0);
			
		// Apply Horizontal Movement
		SetActorPosition(moveMe, 
            GetActorX(moveMe) + FixedMul(xSpeed, FixedMul(FIXED_POINT_SCALE,0.25)),
            GetActorY(moveMe),
            GetActorZ(moveMe),
            0);
            
        SetActorPosition(moveMeToo, 
            GetActorX(moveMe),
            GetActorY(moveMe) + 64.0,
            GetActorFloorZ(moveMe),
            0);
		
		
		SetActorPosition(moveMeCamera, 
            GetActorX(moveMe),
            GetActorY(moveMe) - 16.0,
            GetActorZ(moveMe) + 256.0,
            0);
			
			
		SetActorPitch(moveMeCamera, 0.25);
            
        // Ground check
        if (GetActorZ(moveMe) <= GetActorFloorZ(moveMe))
        {
            isGrounded = 1;
            ySpeed = 0;
            isGroundPounding = 0;
        }
		AddDebugTextLine(StrParam(s:"xSpeed: ", f:xSpeed));
		AddDebugTextLine(StrParam(s:"ySpeed: ", f:ySpeed));
		AddDebugTextLine(StrParam(s:"isGrounded: ", b:isGrounded));
		AddDebugTextLine(StrParam(s:"isGroundPounding: ", b:isGroundPounding));
		AddDebugTextLine(StrParam(s:"jumpReleased: ", b:jumpReleased));		
		AddDebugTextLine(StrParam(s:"x: ", f:GetActorX(moveMe)));
		AddDebugTextLine(StrParam(s:"y: ", f:GetActorY(moveMe)));
		AddDebugTextLine(StrParam(s:"GetActorZ: ", f:GetActorZ(moveMe)));
		AddDebugTextLine(StrParam(s:"GetActorFloorZ: ", f:GetActorFloorZ(moveMe)));
		
		
		// This test snippet was created to figure out how to look up and down
		// Mostly to use the floor as the "background",
		/*
		int tempAngle = FixedDiv(1.0, 150.0);
		int normalizedRotationProgress = ticks % 150;
		tempAngle *= normalizedRotationProgress;
		
		SetActorPitch(moveMeCamera, tempAngle);
		
		AddDebugTextLine(StrParam(s:"tempAngle: ", f:tempAngle));
		AddDebugTextLine(StrParam(s:"ticks: ", i:ticks));
		AddDebugTextLine(StrParam(s:"normalizedRotationProgress: ", i:normalizedRotationProgress));
		
		AddDebugTextLine(StrParam(s:"actualPitch: ", f:GetActorPitch(moveMeCamera)));
		*/
		
		
		
        
		drawDebugText();
		ticks++;
        Delay(1);
    }
}




/*
Useful stuff: 

https://zdoom.org/wiki/CheckPlayerCamera

*/